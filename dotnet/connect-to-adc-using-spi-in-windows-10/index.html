<!doctype html><html><head><title>Amadeus' page</title><link rel=stylesheet href=//amadeusw.com/css/style.css></head><body><div id=container class=centered><header id=title class="containerelement navcontent"><a class=link href=//amadeusw.com><span class=headercontent>Amadeo</span></a></header><div id=subtitle class="accent_dotnet containerelement navcontent"><span class=headercontent>Connect Windows 10 to ADC using SPI</span></div><nav class="accent_dotnet containerelement"><div class=navcontent><a class=link href=/travel/>Travel</a>
<a class=link href=/3dprinting/>3D printing</a>
<a class=link href=/tech/>Electronics</a>
<a class=link href=/projects/>Projects</a>
<a class=link href=/cookery/>Cookery</a>
<a class="link active" href=/dotnet/>.net</a></div></nav><div id=content class=containerelement><main class=centered><article class=dotnet><p>The smart mirror project recently entered the exciting part of working with hardware! The goal is to enable hand wave gesture recognition using two distance sensors placed on either side of the mirror. The first step is to get the data from the sensors and see how it looks like. In this blog post I wanted to focus specifically on <strong>connecting Raspberry Pi to the MCP3008 analog to digital converter using SPI</strong>, based on the <a href=https://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm>Potentiometer Sensor Sample</a> (<a href=https://github.com/ms-iot/samples/tree/develop/PotentiometerSensor/CS>on github</a>). The code for this blog post is at <a href=https://github.com/AmadeusW/raspberryPiTest/>github.com/AmadeusW/raspberryPiTest</a>.</p><p>For the complete process of connecting distance sensors to Raspberry Pi, see my youtube podcast</p><ul><li><a href=http://youtu.be/4mIuIHNF3JA><img src=//amadeusw.comhttp://i.ytimg.com/vi/4mIuIHNF3JA/default.jpg alt=thumbnail>
Smart Mirror episode 6 - Distance Sensor, ADC, SPI - circuit</a></li><li><a href=https://youtu.be/dbNHNvUq2So><img src=//amadeusw.comhttp://i.ytimg.com/vi/dbNHNvUq2So/default.jpg alt=thumbnail>
Smart Mirror episode 7 - Distance Sensor, ADC, SPI - code</a></li></ul><h1 id=a-few-pointers-regarding-the-hardware>A few pointers regarding the hardware</h1><p>See <a href=https://ms-iot.github.io/content/en-US/win10/samples/PinMappingsRPi2.htm>Raspberry Pi 2 Pin Mappings</a> and <a href=http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf>MCP3008 datasheet</a>.</p><ul><li>Connect Pi <code>SPI MOSI</code> to MCP3008 <code>Din</code>, and Pi <code>SPI MISO</code> to MCP3008 <code>Dout</code></li><li>initially I thought output of one device should be connected to the input of another device</li><li>Use either Pi&rsquo;s <code>SPI CS0</code> or <code>SPI CS1</code> pin, you can pick one to use in the code</li><li>this means that you can independently connect two SPI devices</li></ul><p><img src=//amadeusw.com/techBlogData//connect-to-ADC-using-SPI-in-windows-10/circuit.png alt="circuit diagram"></p><h1 id=connecting-to-spi-device>Connecting to SPI device</h1><p>To connect to the ADC, you need to obtain an instance of <code>SpiDevice</code> from <code>Widows.Devices.Spi</code> namespace. To access this namespace, you need to first add a reference to &ldquo;Windows IoT Extensions for the UWP&rdquo;</p><p><img src=//amadeusw.com/techBlogData//connect-to-ADC-using-SPI-in-windows-10/reference.png alt="adding a reference"></p><p>Alright, let&rsquo;s instantiate the <code>SpiDevice</code>. This code is adapted from the Potentiometer Sensor Sample.</p><p>This is boilerplate code where I would pay attention mostly to <code>SpiConnectionSettings</code>. The parameter is the <strong>Chip Select</strong> line you used in the circuit, and <code>ClockFrequency</code> should not exceed the maximum frequency specified by the device&rsquo;s datasheet. I haven&rsquo;t figured out <code>Mode</code>, but <code>Mode0</code> seems to work for <code>MCP3008</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>SpiDevice ADC;
</span></span><span style=display:flex><span><span style=color:#75715e>// . . .</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> settings = <span style=color:#66d9ef>new</span> SpiConnectionSettings(<span style=color:#ae81ff>0</span>)                         <span style=color:#75715e>// Chip Select line 0</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ClockFrequency = <span style=color:#ae81ff>500</span> * <span style=color:#ae81ff>1000</span>,                                    <span style=color:#75715e>// Don&#39;t exceed 3.6 MHz</span>
</span></span><span style=display:flex><span>    Mode = SpiMode.Mode0,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> spiAqs = SpiDevice.GetDeviceSelector(<span style=color:#e6db74>&#34;SPI0&#34;</span>);                <span style=color:#75715e>/* Find the selector string for the SPI bus controller          */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> devicesInfo = <span style=color:#66d9ef>await</span> DeviceInformation.FindAllAsync(spiAqs);     <span style=color:#75715e>/* Find the SPI bus controller device with our selector string  */</span>
</span></span><span style=display:flex><span>ADC = <span style=color:#66d9ef>await</span> SpiDevice.FromIdAsync(devicesInfo[<span style=color:#ae81ff>0</span>].Id, settings);     <span style=color:#75715e>/* Create an SpiDevice with our bus controller and SPI settings */</span>
</span></span></code></pre></div><h1 id=getting-data-from-the-spi-device>Getting data from the SPI device</h1><p>Now here&rsquo;s the real challenging code, and we&rsquo;ll get into detail. Use <code>TransferFullDuplex</code> to read data from the SPI device. You pass in one byte array that tells the device what to do, and another empty array where device&rsquo;s data will go.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] request = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[<span style=color:#ae81ff>3</span>] { <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x80</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] response = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>// . . .        </span>
</span></span><span style=display:flex><span>ADC.TransferFullDuplex(request, response);
</span></span></code></pre></div><p>First, we need to establish the size of the arrays. Let&rsquo;s start with the response buffer:</p><p>The ADC response is 10 bits long. We can fit it into 2 bytes. We also add one byte padding. Hence, the response is 3 bytes long.</p><p>In SPI communication, for every byte we want to receive, we send one byte. Therefore, the request bytes are also 3 bytes long.</p><p>Now, what do we send? The ADC datasheet calls for a 4 bit pattern <code>1000</code> to read from the first channel, and <code>1001</code> to read from the second channel.
A few pages further, the datasheet also says that the message needs to be preceeded with a <code>1</code> bit. So, to read values from the first channel, we send <code>11000</code>.</p><p>Here is where various code snippets I found online get confusing: You can convert <code>11000</code> to hexadecimal <code>0x18</code>. and <code>110000</code> to <code>0x30</code>. Both approaches will work, but the code becomes not maintainable.</p><p>To address this issue, we just need to split the data into bytes in a different way: The first byte will contain the initial <code>1</code>, and the second byte will contain the channel selecting pattern. Hence, we will send <code>0000 0001 1000 xxxx xxxx xxxx</code> (<code>x</code> is <code>don't care</code>), which translates to <code>{ 0x01, 0x80, 0 }</code>. Any change of the pattern will be reflected exclusively in the third hexadecimal digit (now <code>8</code>).</p><h1 id=converting-byte-to-int>Converting byte[] to int</h1><p>Finally, we must convert the raw response of type <code>byte[]</code> to a more useful type, such as <code>int</code>. What happens in the <code>ConvertToInt</code> method, then?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>int</span> result = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>result = data[<span style=color:#ae81ff>1</span>] &amp; <span style=color:#ae81ff>0x03</span>;
</span></span><span style=display:flex><span>result &lt;&lt;= <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>result += data[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> result;
</span></span></code></pre></div><p>The datasheet of the ADC says that the device outputs 10-bit chunks of data. This code extracts these ten bytes from the input <code>data</code> array.</p><p>Let&rsquo;s illustrate this code by plugging in values into variables. Suppose that <code>byte[] data</code> looks like this: <code>AAAAaaaa BBBBbbbb CCCCcccc</code>, and the ten bytes with actual data are <code>bbCCCCcccc</code>.</p><ul><li><code>data[1] & 0x03</code> becomes <code>BBBBbbbb & 00000011</code>, which is <code>000000bb</code></li><li><code>result &lt;&lt;= 8</code> transforms this into <code>000000bb 00000000</code>.</li><li><code>result += data[2];</code> produces <code>000000bb CCCCcccc</code>, which is the ten bits that we were after!</li></ul><h1 id=conclusion>Conclusion</h1><p>These were the biggest obstacles that I had when working with the SPI code. There is some non trivial math in this code, so feel free to comment below, or reach out to me on Twitter <a href=https://twitter.com/HiAmadeus>@HiAmadeus</a>. To see how this code is used, watch <a href=https://youtu.be/dbNHNvUq2So>Smart Mirror episode 7 - Distance Sensor, ADC, SPI - code</a>.</p><p>Happy hacking!</p></article></main></div><div id=footer class=containerelement><div id=footerName><abbr title="Pronounce: A-ma-de-ows Vee-cho-reck">Amadeus Wieczorek</abbr></div><div id=footerUnderName>I build productivity tools.</div><ul id=footerLinks><li><a href=//github.com/amadeusw>My github</a></li><li><a href=//amadeusw.com/portfolio>2013 portfolio</a></li><li><a href=feed.xml>RSS feed</a></li><li><a href=#>Scroll to top</a></li></div></div></div></body></html>